#!/usr/bin/env python3
#
# References:
# - https://github.com/virt-manager/virt-manager/blob/master/virtManager/viewers.py
# - http://lazka.github.io/pgi-docs/#SpiceClientGLib-2.0
# - spice-gtk/src/spicy-screenshot.c
# - https://linuxtv.org/downloads/v4l-dvb-apis/uapi/v4l/pixfmt-packed-rgb.html
# - http://zulko.github.io/blog/2013/09/27/read-and-write-video-frames-in-python-using-ffmpeg/
# - https://msdn.microsoft.com/en-us/library/windows/desktop/aa473780.aspx
import argparse
import logging
import time
import ctypes
from enum import Enum
import tempfile
import subprocess
import signal

from gi.repository import GLib
from gi.repository import GObject

import gi
gi.require_version('SpiceClientGLib', '2.0')
from gi.repository import SpiceClientGLib

# Maximum framerate timer error allowance (percent of frame interval)
FRAMERATE_ERR_LIMIT_PCT = 10.0

class SpiceSurfaceFmt(Enum):
    # spice-1/spice/enums.h
    SPICE_SURFACE_FMT_INVALID = 0
    SPICE_SURFACE_FMT_1_A = 1
    SPICE_SURFACE_FMT_8_A = 8
    SPICE_SURFACE_FMT_16_555 = 16
    SPICE_SURFACE_FMT_32_xRGB = 32
    SPICE_SURFACE_FMT_16_565 = 80
    SPICE_SURFACE_FMT_32_ARGB = 96


class Display(GObject.GObject):
    def __init__(self, channel, width, height, stride, shmid, imgdata):
        self.channel = channel
        self.width   = width
        self.height  = height
        self.stride  = stride
        self.shmid   = shmid

        # Ensure there is no width padding
        # stride [bytes] == width [pixels] * 4 [bytes / pixel]
        assert(self.stride == self.width * self.bytes_per_pixel)

        imgdata_bytes = stride * height
        self.imgdata = ctypes.cast(imgdata, ctypes.POINTER(ctypes.c_ubyte * imgdata_bytes))

    @staticmethod
    def get_format_class(format):
        return {
            SpiceSurfaceFmt.SPICE_SURFACE_FMT_32_xRGB:  Display32RGB,
            # TODO: Other formats
        }[format]

    def __repr__(self):
        return '{}(channel={}, width={}, height={}, stride={}, shmid={}, imgdata={})'.format(
                type(self), self.channel, self.width, self.height, self.stride, self.shmid, self.imgdata)

class Display32RGB(Display):
    bytes_per_pixel = 4
    ffmpeg_pix_fmt = 'bgr0'     # Each pixel is 4 bytes: BGR0,BGR0,...

    def write_frame(self, f):
        return f.write(self.imgdata.contents)


class SpiceRecorder(GObject.GObject):
    def __init__(self, outfile, framerate=24):
        GObject.GObject.__init__(self)

        self.outfile = outfile
        self.framerate = framerate

        self._spice_session = None
        self._display = None
        self._main_channel = None
        self._display_channel = None

        self._last_frame_t = None

        self._num_frames_recorded = 0
        self._num_bytes_recorded = 0
        self._start_time = None

    def _create_spice_session(self):
        self._spice_session = SpiceClientGLib.Session(read_only=True)
        SpiceClientGLib.set_session_option(self._spice_session)

        GObject.GObject.connect(self._spice_session, "channel-new",
                                self._channel_new_cb)

    def _channel_new_cb(self, session, channel):
        logging.debug("New channel signal: channel=%s", channel)

        # Dispatch
        cb = {
            SpiceClientGLib.MainChannel:    self._new_main_channel,
            SpiceClientGLib.DisplayChannel: self._new_display_channel
        }.get(type(channel))
        if cb:
            cb(channel)

    def _new_main_channel(self, channel):
            self._main_channel = channel
            self._main_channel.connect_after("channel-event",
                                        self._main_channel_event_cb)

    def _new_display_channel(self, channel):
            channel_id = channel.get_property("channel-id")
            if channel_id != 0:
                logging.warning("Spice multi-head unsupported")
                return

            if self._display_channel:
                logging.warning("Display channel already set")
                return
            self._display_channel = channel

            # See spice-gtk/src/spice-widget.c:channel_new()
            self._display_channel.connect_after("display-primary-create",
                                           self._display_primary_create_cb)
            self._display_channel.connect_after("display-primary-destroy",
                                           self._display_primary_destroy_cb)

            channel.connect()



    def _main_channel_event_cb(self, channel, event):
        logging.debug("Main channel %s event %s", channel, event)

    def _display_primary_create_cb(self, channel, format, width, height, stride, shmid, imgdata):
        format = SpiceSurfaceFmt(format)
        logging.debug("display-primary-create channel=%s format=%s", channel, format)
        assert not self._display
        self._display = Display.get_format_class(format)(channel, width, height, stride, shmid, imgdata)
        logging.debug("_display: %s", self._display)

        self._start_time = time.time()
        self._record_frame()
        GLib.timeout_add(int(1000 / self.framerate), self._record_frame)


    def _display_primary_destroy_cb(self, channel):
        logging.debug("display-primary-destroy channel %s", channel)

    def _record_frame(self):
        now = time.time()

        # Calculate framerate timer error
        t_frame = 1 / self.framerate
        if self._last_frame_t:
            dt = now - self._last_frame_t
            err = dt - t_frame
            err_pct = (err / t_frame) * 100
            if err_pct > FRAMERATE_ERR_LIMIT_PCT:
                logging.warning("Framerate error exceeds threshold: dt={} err={} ({}%)".format(dt, err, err_pct))
        self._last_frame_t = now

        # Write the frame!
        b = self._display.write_frame(self.outfile)
        self._num_frames_recorded += 1
        self._num_bytes_recorded += b

        return True

    @property
    def elapsed_time(self):
        return time.time() - self._start_time

    @property
    def frames_recorded(self):
        return self._num_frames_recorded

    @property
    def bytes_recorded(self):
        return self._num_bytes_recorded

    def get_resolution(self):
        if not self._display_channel:
            return None
        return self._display_channel.get_properties("width", "height")

    def open_host(self, host='localhost', port=5900, tlsport=None):
        self._create_spice_session()

        logging.debug("Spice connecting to host=%s port=%s tlsport=%s",
            host, port, tlsport)
        self._spice_session.set_property("host", str(host))
        if port:
            self._spice_session.set_property("port", str(port))
        if tlsport:
            self._spice_session.set_property("tls-port", str(tlsport))

        self._spice_session.connect()

def logging_to_ffmpeg_loglevel(ll):
    return {
        'DEBUG':    'debug',
        'INFO':     'info',
        'WARNING':  'warning',
        'ERROR':    'error',
        'CRITICAL': 'fatal',
    }[ll]

def parse_args():
    ap = argparse.ArgumentParser()
    ap.add_argument('output')
    ap.add_argument('--vcodec', default='libx264',
            help='Set the output video codec (see "ffmpeg -encoders" for choices)')
    ap.add_argument('--loglevel', choices=['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'],
            help='Set the logging level', default='WARNING')
    ap.add_argument('-r', '--framerate', type=int, default=24)
    return ap.parse_args()


def main():
    args = parse_args()
    logging.basicConfig(level=args.loglevel)

    # Record
    with tempfile.NamedTemporaryFile('w+b', prefix='spice-record-', suffix='.raw') as rawf:
        sp = SpiceRecorder(rawf, framerate=args.framerate)
        sp.open_host()

        loop = GLib.MainLoop()

        def sigint_handler(signum, frame):
            loop.quit()
        old = signal.signal(signal.SIGINT, sigint_handler)

        print("Press Ctrl+C to stop")
        loop.run()

        print("Done recording")
        signal.signal(signal.SIGINT, old)


        # Convert video
        rawf.seek(0)
        d = sp._display
        ffmpeg_args = [
            'ffmpeg',
            '-loglevel', logging_to_ffmpeg_loglevel(args.loglevel),
            '-y',
            '-f', 'rawvideo',
            '-vcodec', 'rawvideo',
            '-s', '{}x{}'.format(d.width, d.height),
            '-pix_fmt', d.ffmpeg_pix_fmt,
            '-r', str(args.framerate),
            '-i', '-',  # stdin
            '-an',
            '-vcodec', args.vcodec,
            args.output
        ]
        logging.debug("Invoking FFMPEG: {}".format(ffmpeg_args))
        subprocess.check_call(ffmpeg_args, stdin=rawf)


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print("Exiting due to Ctrl+C")
