#!/usr/bin/env python3
#
# References:
# - https://github.com/virt-manager/virt-manager/blob/master/virtManager/viewers.py
# - http://lazka.github.io/pgi-docs/#SpiceClientGLib-2.0
# - spice-gtk/src/spicy-screenshot.c
# - https://linuxtv.org/downloads/v4l-dvb-apis/uapi/v4l/pixfmt-packed-rgb.html
# - http://zulko.github.io/blog/2013/09/27/read-and-write-video-frames-in-python-using-ffmpeg/
# - https://msdn.microsoft.com/en-us/library/windows/desktop/aa473780.aspx
# - https://superuser.com/a/1136854/101823
# - https://ffmpeg.org/ffmpeg-filters.html
# - https://ffmpeg.org/ffmpeg-filters.html#scale
# - https://ffmpeg.org/ffmpeg-filters.html#concat
import argparse
import logging
import time
import ctypes
from enum import Enum
import tempfile
import subprocess
import signal
import os
import sys
import libvirt
from uuid import UUID
import xml.etree.ElementTree as ET
from urllib.parse import urlparse

from gi.repository import GLib
from gi.repository import GObject

import gi
gi.require_version('SpiceClientGLib', '2.0')
from gi.repository import SpiceClientGLib

# Maximum framerate timer error allowance (percent of frame interval)
FRAMERATE_ERR_LIMIT_PCT = 10.0

class AppError(Exception):
    def __init__(self, message, exit_code=2):
        super().__init__(message)
        self.exit_code = exit_code

class SpiceSurfaceFmt(Enum):
    # spice-1/spice/enums.h
    SPICE_SURFACE_FMT_INVALID = 0
    SPICE_SURFACE_FMT_1_A = 1
    SPICE_SURFACE_FMT_8_A = 8
    SPICE_SURFACE_FMT_16_555 = 16
    SPICE_SURFACE_FMT_32_xRGB = 32
    SPICE_SURFACE_FMT_16_565 = 80
    SPICE_SURFACE_FMT_32_ARGB = 96


class Display(GObject.GObject):
    def __init__(self, channel, width, height, stride, shmid, imgdata, outfile):
        self.channel = channel
        self.width   = width
        self.height  = height
        self.stride  = stride
        self.shmid   = shmid

        # Ensure there is no width padding
        # stride [bytes] == width [pixels] * 4 [bytes / pixel]
        assert(self.stride == self.width * self.bytes_per_pixel)

        imgdata_bytes = stride * height
        self.imgdata = ctypes.cast(imgdata, ctypes.POINTER(ctypes.c_ubyte * imgdata_bytes))

        self.outfile = outfile

        self._start_time = time.time()
        self._end_time = None
        self._num_frames_recorded = 0
        self._num_bytes_recorded = 0


    @staticmethod
    def get_format_class(format):
        return {
            SpiceSurfaceFmt.SPICE_SURFACE_FMT_32_xRGB:  Display32RGB,
            # TODO: Other formats
        }[format]

    def __repr__(self):
        return '{}(channel={}, width={}, height={}, stride={}, shmid={}, ' \
               'imgdata={}, outfile={})'.format(
                type(self), self.channel, self.width, self.height, self.stride,
                self.shmid, self.imgdata, self.outfile)


    def destroy(self):
        # Doesn't actually destroy anything -- called on destroy callback
        self.imgdata = None
        self._end_time = time.time()

    def write_frame(self):
        assert self.imgdata
        b = self._do_write_frame()
        self._num_frames_recorded += 1
        self._num_bytes_recorded += b
        return b

    @property
    def frames_recorded(self):
        return self._num_frames_recorded

    @property
    def bytes_recorded(self):
        return self._num_bytes_recorded

    @property
    def duration(self):
        end = self._end_time or time.time()
        return end - self._start_time


class Display32RGB(Display):
    bytes_per_pixel = 4
    ffmpeg_pix_fmt = 'bgr0'     # Each pixel is 4 bytes: BGR0,BGR0,...

    def _do_write_frame(self):
        return self.outfile.write(self.imgdata.contents)


class SpiceRecorder(GObject.GObject):
    __gsignals__ = {
        "periodic-update":  (GObject.SignalFlags.RUN_FIRST, None, []),
    }

    def __init__(self, domain, framerate=24):
        GObject.GObject.__init__(self)

        self._vm = domain

        self.framerate = framerate

        self._spice_session = None
        self._main_channel = None
        self._display_channel = None
        self._displays = []             # displays created, in chrono. order
        self._active_display = None     # currently active display

        self._last_frame_t = None

        self._last_periodic_update_t = None
        self._num_frames_recorded = 0
        self._num_bytes_recorded = 0
        self._start_time = None

    def _get_fd_for_open(self):
        # Reference:
        # https://github.com/virt-manager/virt-manager/blob/b8dccf6a/virtManager/viewers.py#L139

        uri = urlparse(self._vm._conn.getURI())
        if uri.hostname:
            # OpenGraphics only works for local libvirtd connections
            return None

        # TODO: Additional checks -- see virt-manager Viewer._get_fd_for_open

        fd = self._vm.openGraphicsFD(0,
                libvirt.VIR_DOMAIN_OPEN_GRAPHICS_SKIPAUTH)
        logging.debug('openGraphicsFD(0) returned %d', fd)
        return fd

    def _create_spice_session(self):
        assert not self._spice_session
        self._spice_session = SpiceClientGLib.Session(read_only=True)
        SpiceClientGLib.set_session_option(self._spice_session)

        GObject.GObject.connect(self._spice_session, "channel-new",
                                self._channel_new_cb)

    def _channel_new_cb(self, session, channel):
        logging.debug("New channel signal: channel=%s", channel)

        GObject.GObject.connect(channel, "open-fd",
                                self._channel_open_fd_request)

        # Dispatch
        cb = {
            SpiceClientGLib.MainChannel:    self._new_main_channel,
            SpiceClientGLib.DisplayChannel: self._new_display_channel
        }.get(type(channel))
        if cb:
            cb(channel)

    def _channel_open_fd_request(self, channel, tls_ignore):
        logging.debug("Requesting fd for channel: %s", channel)

        fd = self._get_fd_for_open()
        channel.open_fd(fd)


    def _new_main_channel(self, channel):
            self._main_channel = channel
            self._main_channel.connect_after("channel-event",
                                        self._main_channel_event_cb)

    def _new_display_channel(self, channel):
            channel_id = channel.get_property("channel-id")
            if channel_id != 0:
                logging.warning("Spice multi-head unsupported")
                return

            if self._display_channel:
                logging.warning("Display channel already set")
                return
            self._display_channel = channel

            # See spice-gtk/src/spice-widget.c:channel_new()
            self._display_channel.connect_after("display-primary-create",
                                           self._display_primary_create_cb)
            self._display_channel.connect_after("display-primary-destroy",
                                           self._display_primary_destroy_cb)

            channel.connect()



    def _main_channel_event_cb(self, channel, event):
        logging.debug("Main channel %s event %s", channel, event)

    def _display_primary_create_cb(self, channel, format, width, height, stride, shmid, imgdata):
        format = SpiceSurfaceFmt(format)
        logging.debug("display-primary-create channel=%s format=%s %dx%d", channel, format, width, height)
        if self._active_display:
            logging.warning("Hmm? _active_display is set: %s", self._active_display)
            return

        rawf = tempfile.NamedTemporaryFile('w+b', prefix='spice-record-',
                suffix='{}x{}.raw'.format(width, height), delete=False)
        d = Display.get_format_class(format)(channel, width, height, stride, shmid, imgdata, rawf)
        logging.debug("New display: %s", d)
        self._active_display = d
        self._displays.append(d)

        # First display?
        if len(self._displays) == 1:
            self._start_time = time.time()
            self._record_frame()
            GLib.timeout_add(int(1000 / self.framerate), self._record_frame)

    def _display_primary_destroy_cb(self, channel):
        logging.debug("display-primary-destroy channel %s", channel)

        self._active_display.destroy()
        self._active_display = None

    def _record_frame(self):
        now = time.time()

        # Calculate framerate timer error
        t_frame = 1 / self.framerate
        if self._last_frame_t:
            dt = now - self._last_frame_t
            err = dt - t_frame
            err_pct = (err / t_frame) * 100
            if err_pct > FRAMERATE_ERR_LIMIT_PCT:
                logging.warning("Framerate error exceeds threshold: dt={} err={} ({}%)".format(dt, err, err_pct))
        self._last_frame_t = now

        # Ugh, can we miss frames here while there is no display?
        if not self._active_display:
            return

        # Write the frame!
        b = self._active_display.write_frame()
        self._num_frames_recorded += 1
        self._num_bytes_recorded += b

        # Perform periodic update
        if self._last_periodic_update_t:
            dt = now - self._last_periodic_update_t
        if not self._last_periodic_update_t or (dt > 1.0):
            self.emit("periodic-update")
            self._last_periodic_update_t = now

        return True

    @property
    def displays(self):
        return list(self._displays)

    @property
    def elapsed_time(self):
        return time.time() - self._start_time

    @property
    def frames_recorded(self):
        return self._num_frames_recorded

    @property
    def bytes_recorded(self):
        return self._num_bytes_recorded

    def get_resolution(self):
        if not self._display_channel:
            return None
        return self._display_channel.get_properties("width", "height")

    def _open_fd(self, fd):
        self._create_spice_session()

        logging.debug("Spice connecting via fd=%d", fd)
        self._spice_session.open_fd(fd)

    def _open_host(self):
        coninfo = domain_extract_connect_info(dom)

        self._create_spice_session()

        logging.debug("Spice connecting to host=%s port=%s tlsport=%s",
            coninfo.ghost, coninfo.gport, coninfo.gtlsport)
        self._spice_session.set_property("host", str(coninfo.ghost))
        if port:
            self._spice_session.set_property("port", str(coninfo.gport))
        if tlsport:
            self._spice_session.set_property("tls-port", str(coninfo.gtlsport))

        self._spice_session.connect()

    def open(self):
        # References:
        #   - virt_viewer_open_connection()
        #   - virt-manager Viewer._open

        fd = self._get_fd_for_open()
        if fd is not None:
            self._open_fd(fd)
        else:
            self._open_host()


def convert_concat_videos(displays, framerate, outcodec, outpath, loglevel=None):
    ffmpeg_args = [
        'ffmpeg',
        '-loglevel', loglevel,
        '-y',
    ]

    # Determine the output video resolution
    maxw, maxh = 0, 0
    for d in displays:
        maxw = max(maxw, d.width)
        maxh = max(maxh, d.height)

    # Establish raw input files with their attributes
    for d in displays:
        ffmpeg_args += [
            '-f', 'rawvideo',
            '-vcodec', 'rawvideo',
            '-pix_fmt', d.ffmpeg_pix_fmt,
            '-r', str(framerate),
            '-an',
            '-s', '{}x{}'.format(d.width, d.height),
            '-i', d.outfile.name,   # TODO: "pipe:{fd}"
        ]

    # Build our complex filtergraph:
    # 1) Create appropriately scaled versions of each input stream named [v{i}]
    filters = []
    for i,d in enumerate(displays):
        # Explained:
        #   [{i}:v]     Take the i'th input file's video stream,
        #   scale=      Scale it to w x h, maintaining aspect ratio,
        #               decreasing the output size if required to do so,
        #   pad=        And if so, pad it out to w x h, centering it in the frame.
        #   [v{i}]      Name the output stream [v{i}]
        filt = '[{i}:v] scale={w}:{h}:force_original_aspect_ratio=decrease,' \
                'pad={w}:{h}:(ow-iw)/2:(oh-ih)/2  [v{i}]'.format(
                i=i, w=maxw, h=maxh)
        filters.append(filt)

    # 2) Concatenate the [v{i}] videos to [outv]
    # Explained:
    #   [v{i}]      Take each of the [v{i}] scaled streams,
    #   concat=     concatenate all 'n' of them together into one video output.
    #   [outv]      Name the output stream [outv]
    filt = ' '.join('[v{i}]'.format(i=i) for i in range(len(displays)))
    filt += 'concat=n={n}:v=1:a=0 [outv]'.format(n=len(displays))
    filters.append(filt)


    ffmpeg_args += [
        # Apply the compex filtergraph
        '-filter_complex', '; '.join(filters),

        # Specify output video parameters
        '-vcodec', outcodec,
        '-pix_fmt', 'yuv420p',  # avoid warning

        # Map the [outv] to the output file
        '-map', '[outv]',
        outpath
    ]
    logging.debug("Invoking FFMPEG: {}".format(ffmpeg_args))
    subprocess.check_call(ffmpeg_args)


def lookup_domain(conn, key):
    try:
        # Try ID
        try:
            return conn.lookupByID(int(key))
        except ValueError:
            pass

        # Try UUID
        try:
            return conn.lookupByUUID(UUID(key))
        except ValueError:
            pass

        # Try name
        return conn.lookupByName(key)

    except libvirt.libvirtError as err:
        if err.get_error_code() != libvirt.VIR_ERR_NO_DOMAIN:
            raise
        raise AppError(str(err))


def domain_extract_connect_info(domain):
    # See
    #   virt_viewer_extract_connect_info()
    #   virt_viewer_app_set_connect_info()
    tree = ET.fromstring(domain.XMLDesc())
    ET.dump(tree)

    gfx = tree.find('devices/graphics')

    class ConnectInfo:
        pass
    o = ConnectInfo()
    o.type = gfx.get('type')
    if o.type != 'spice':
        raise ValueError('Graphics type "{}" not supported; must be "spice"'.format(o.type))

    o.gport = gfx.get('port')
    o.gtlsport = gfx.get('tlsport')
    o.ghost = gfx.get('listen')
    o.unixsock = gfx.get('socket')

    if o.ghost and o.gport:
        logging.info('Guest graphics address is {}:{}'.format(o.ghost, o.gport))
    elif o.unixsock:
        logging.info('Guest graphics address is {}'.format(o.unixsock))
    else:
        logging.info('Using direct libvirt connection')

    uri = urlparse(domain._conn.getURI())
    o.host = uri.hostname
    o.transport = uri.scheme
    o.user = uri.username
    o.password = uri.password
    o.port = uri.port

    return o


def domain_wait(domain, target_state):
    printed = False
    while True:
        state, reason = domain.state()
        if state == target_state:
            break
        if not printed:
            print("Waiting for domain to enter state {}".format(target_state))
            printed = True
        time.sleep(0.1)         # TODO: Handle asynchronously: See virt_viewer_domain_event()

def unique_filename(path):
    base, ext = os.path.splitext(path)
    idx = None

    while True:
        if idx is not None:
            path = "{}_{}{}".format(base, idx, ext)
        else:
            path = base + ext

        try:
            f = open(path, 'x')
            f.close()
            return path
        except FileExistsError:
            idx = 0 if (idx is None) else (idx + 1)

def libvirt_err_handler(ignore, err):
    if err[3] != libvirt.VIR_ERR_ERROR:
        # Don't log libvirt errors: global error handler will do that
        logging.warn("Non-error from libvirt: '%s'" % err[2])

def logging_to_ffmpeg_loglevel(ll):
    return {
        'DEBUG':    'debug',
        'INFO':     'info',
        'WARNING':  'warning',
        'ERROR':    'error',
        'CRITICAL': 'fatal',
    }[ll]

def parse_args():
    ap = argparse.ArgumentParser()

    # Recording options
    ap.add_argument('--vcodec', default='libx264',
            help='Set the output video codec (see "ffmpeg -encoders" for choices)')
    ap.add_argument('--loglevel', choices=['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'],
            help='Set the logging level (default=WARNING)', default='WARNING')
    ap.add_argument('-r', '--framerate', type=int, default=24)

    # Libvirt options and domain
    ap.add_argument('-c', '--connect', dest='libvirt_uri',
            help='Connect to hypervisor (e.g. qemu:///system)')
    ap.add_argument('machine', metavar='DOMAIN-NAME|ID|UUID',
            help='Machine to record')

    ap.add_argument('-o', '--output', metavar='FILENAME',
            help='Output filename (defaults to <domain-name>.mp4)')

    return ap.parse_args()


def format_datasize(b):
    suffixes = ['', 'ki', 'Mi', 'Gi', 'Ti']
    for s in suffixes:
        if (b < 1024) or (s == suffixes[-1]):
            break
        b /= 1024.0
    return '{:0.02f} {}B'.format(b, s)

def main():
    args = parse_args()
    logging.basicConfig(level=args.loglevel)

    libvirt.registerErrorHandler(f=libvirt_err_handler, ctx=None)

    # Open libvirt connection
    logging.info("Opening connection to %s", args.libvirt_uri)
    conn = libvirt.open(args.libvirt_uri)   # read only access prevents virDomainOpenGraphicsFD

    # Try to get domain
    dom = lookup_domain(conn, args.machine)
    logging.info('Using domain "%s" (%s)', dom.name(), dom.UUIDString())

    if not args.output:
        args.output = unique_filename(dom.name() + '.mp4')

    domain_wait(dom, libvirt.VIR_DOMAIN_RUNNING)

    #############
    # Open spice session
    sp = SpiceRecorder(dom, framerate=args.framerate)
    sp.open()

    # Record raw video
    def periodic_update(sp):
        print("\r" + " "*80, end="")
        print("\r{:<20}{:<20}{:<20}".format(
            "{:0.02f} sec".format(sp.elapsed_time),
            "{} frames".format(sp.frames_recorded),
            format_datasize(sp.bytes_recorded),
            ), end="")
    sp.connect("periodic-update", periodic_update)

    loop = GLib.MainLoop()

    def sigint_handler(signum, frame):
        print("INTERRUPT")
        loop.quit()
    old = signal.signal(signal.SIGINT, sigint_handler)

    print("Recording... Press Ctrl+C to stop")
    loop.run()
    signal.signal(signal.SIGINT, old)

    print("-"*80)
    print("Recorded displays:")
    maxw, maxh = 0, 0
    for n,d in enumerate(sp.displays):
        print("  {}: {}x{} {:>4} frames  {:>10}  {:0.02f} sec".format(n, d.width, d.height,
            d.frames_recorded,
            format_datasize(d.bytes_recorded),
            d.duration))
        maxw = max(maxw, d.width)
        maxh = max(maxh, d.height)
    print("Final: {}x{}".format(maxw, maxh))
    print("-"*80)


    # Convert video
    print("\nDone recording. Converting...")
    convert_concat_videos(
            displays = sp.displays,
            framerate = args.framerate,
            outcodec = args.vcodec,
            outpath = args.output,
            loglevel = logging_to_ffmpeg_loglevel(args.loglevel),
            )

    # TODO: Pass tempfile file descriptors to ffmpeg using -i pipe:{fd}.
    # This requires passing close_fds=False.
    # Note that we can't currently do this because the tempfiles were opened
    # in a different process (thanks to MainLoop)!

    print("\nCleaning up...")
    for d in sp.displays:
        os.unlink(d.outfile.name)

    print("\n{} written!".format(args.output))


if __name__ == '__main__':
    try:
        main()
        sys.exit(0)
    except KeyboardInterrupt:
        print("Exiting due to Ctrl+C")
        sys.exit(0)
    except AppError as err:
        print(err)
        sys.exit(err.exit_code)
